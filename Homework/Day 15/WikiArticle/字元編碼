字元編碼（英語：Character encoding）、字集碼是把字元集中的字元編碼為指定集合中某一物件（例如：位元模式、自然數序列、8位元組或者電脈衝），以便文字在電腦中儲存和通過通信網路的傳遞。常見的例子包括將拉丁字母表編碼成摩斯電碼和ASCII。其中，ASCII將字母、數字和其它符號編號，並用7位元的二進位來表示這個整數。通常會額外使用一個擴充的位元，以便於以1個位元組的方式儲存。

在電腦技術發展的早期，如ASCII（1963年）和EBCDIC（1964年）這樣的字元集逐漸成為標準。但這些字元集的局限很快就變得明顯，於是人們開發了許多方法來擴充它們。對於支援包括東亞CJK字元家族在內的寫作系統的要求能支援更大量的字元，並且需要一種系統而不是臨時的方法實現這些字元的編碼。

按照慣例，人們認為字元集和字元編碼是同義詞，因為使用同樣的標準來定義提供什麼字元並且這些字元如何編碼到一系列的代碼單元（通常一個字元一個單元）。由於歷史的原因，MIME和使用這種編碼的系統使用術語字元集來表示用於將一組字元編碼成一系列八位位元組資料的整個系統。

由統一碼和通用字元集所構成的現代字元編碼模型則沒有跟從簡單字元集的觀點。它們將字元編碼的概念分為：有哪些字元、它們的編號、這些編號如何編碼成一系列的「碼元」（有限大小的數字）以及最後這些單元如何組成八位位元組流。區分這些概念的核心思想是建立一個能夠用不同方法來編碼的一個通用字元集。為了正確地表示這個模型需要更多比「字元集」和「字元編碼」更為精確的術語表示。在Unicode Technical Report (UTR) #17中，現代編碼模型分為5個層次，所用的術語列在下面：

高層機制（higher level protocol）提供了額外資訊，用於選擇Unicode字元的特定變種，如XML屬性xml:lang

字元對映（character map）在Unicode中保持了其傳統意義：從字元序列到編碼後的位元組序列的對映，包括了上述的CCS, CEF, CES層次。

術語字元編碼（character encoding），字元對映（character map），字元集（character set）或者頁碼，在歷史上往往是同義概念，即字元表（repertoire）中的字元如何編碼為碼元的流（stream of code units）–通常每個字元對應單個碼元。

碼元（Code Unit，也稱「代碼單元」）是指一個已編碼的文字中具有最短的位元組合的單元。對於UTF-8來說，碼元是8位元長；對於UTF-16來說，碼元是16位元長；對於UTF-32來說，碼元是32位元長[1]。碼值（Code Value）是過時的用法。

頁碼通常意味著面向位元組的編碼，但強調是一套用於不能語言的編碼方案的集合.著名的如"Windows"頁碼系列，"IBM"/"DOS"頁碼系列.

IBM的字元資料表示體系（Character Data Representation Architecture - CDRA）與編碼字元集識別碼（coded character set identifiers - CCSIDs） 常常把charset, character set, code page, or CHARMAP等類似意義的術語混用.

Unix或Linux不使用頁碼概念，它們用charmap，比locales具有更廣泛的含義.

與上文的編碼字元集（Coded Character Set - CCS）不同，字元編碼（character encoding）是從抽象字元到代碼字（code word）的對映. HTTP（與MIME）的用法中，字元集（character set）與字元編碼同義，但與CCS不是一個意思.

由於有很多種字元編碼方法被使用，從一種字元編碼轉換到另一種，需要一些工具。

跨平台：

Linux:

Microsoft Windows:

