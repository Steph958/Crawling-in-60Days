正規表示式（英語：Regular Expression，常簡寫為regex、regexp或RE），又稱正規表達式、正規表示法、規則運算式、常規表示法，是電腦科學的一個概念。正規表示式使用單個字串來描述、符合一系列符合某個句法規則的字串。在很多文字編輯器裡，正則表達式通常被用來檢索、替換那些符合某個模式的文字。

許多程式設計語言都支援利用正則表達式進行字串操作。例如，在Perl中就內建了一個功能強大的正則表達式引擎。正則表達式這個概念最初是由Unix中的工具軟體（例如sed和grep）普及開的。

Regular Expression的Regular一般被譯為正規、正則或常規。此處的Regular即是規則、規律的意思，Regular Expression即「描述某種規則的表達式」之意。[來源請求]

最初的正規表示式出現於理論電腦科學的自動控制理論和形式化語言理論中。在這些領域中有對計算（自動控制）的模型和對形式化語言描述與分類的研究。

1940年，沃倫·麥卡洛克與沃爾特·皮茨將神經系統中的神經元描述成小而簡單的自動控制元。

1950年代，數學家史蒂芬·科爾·克萊尼利用稱之為「正規集合」的數學符號來描述此模型。肯·湯普遜將此符號系統引入編輯器QED（英語：QED (text editor)），隨後是Unix上的編輯器ed，並最終引入grep。自此以後，正則表達式被廣泛地應用於各種Unix或類Unix系統的工具中。正規表示式的POSIX規範，分為基本型正規表示式（Basic Regular Expression，BRE）和擴充型正規表示式（Extended Regular Express，ERE）兩大流派。在相容POSIX的UNIX系統上，grep和egrep之類的工具都遵循POSIX規範，一些資料庫系統中的正規表示式也符合POSIX規範。grep、vi、sed都屬於BRE，是歷史最早的正規表示式，因此元字元必須轉譯之後才具有特殊含義。egrep、awk則屬於ERE，元字元不用轉譯

Perl的正規表示式源自於Henry Spencer（英語：Henry Spencer）於1986年1月19日發布的regex，它已經演化成了PCRE（Perl相容正規表示式，Perl Compatible Regular Expressions（英語：PCRE）），一個由Philip Hazel（英語：Philip Hazel）開發的，為很多現代工具所使用的庫。

各程式語言之間關於正則表達式的整合，目前[何時？]開發進展得很差。Perl6的子專案Apocalypse的設計中已考慮到了這點。

正規表示式可以用形式化語言理論的方式來表達。正規表示式由常數和算子組成，它們分別表示字串的集合和在這些集合上的運算。給定有限字母表Σ定義了下列常數：

定義了下列運算：

上述常數和算子形成了克萊尼代數。

很多課本使用對選擇使用符號



∪


{\displaystyle \cup }

、



+


{\displaystyle +}

或



∨


{\displaystyle \vee }

替代豎線。

為了避免括號，假定Kleene星號有最高優先級，接著是串接，接著是聯集。如果沒有歧義則可以省略括號。例如：(ab)c可以寫為abc而a|(b(c*))可以寫為a|bc*。

例子：

為了使表達式更簡潔，正規表示式也定義了?和+；aa*等於a+，表示a出現至少一次；而(a|ε)等於a?，表示a出現1次或不出現。有的定義中增加了補算子



∼


{\displaystyle \sim }

；



∼
R


{\displaystyle \sim R}

表示在




Σ

∗




{\displaystyle \Sigma ^{*}}

上但不在



R


{\displaystyle R}

中的所有字串的集合。補算子在理論上並非必要，因為它可以使用其他算子來表達，但它可以使一些表達式變得更加簡潔。

這種意義上的正規表示式可以表達正規語言，是可被有限狀態自動機精確接受的語言類。但是在簡潔性上有重要區別。某類正規語言只能用大小指數增長的自動機來描述，而要求的正規表示式的長度只線性的增長。

正規表示式對應於喬姆斯基層級的類型-3文法。但通常程式語言或其相關庫（例如PCRE）中實現的正規表示式的表達能力是喬姆斯基層級中類型-3文法的超集[來源請求]。在另一方面，在正規表示式和不導致這種大小上的爆炸的非確定有限狀態自動機（NFA）之間有簡單的對映；為此NFA經常被用作正規表示式的替表示式。

這種形式化中存在著冗餘，典型的體現是存在不同的正規表示式可以表達同樣的語言。有可能對兩個給定正規表示式寫一個演算法來判定它們所描述的語言是否本質上相等，即簡約每個表達式到極小確定有限自動機，確定它們是否同構（等價）。這種冗餘可以消減到什麼程度？我們可以找到仍有完全表達力的正規表示式的有趣的子集嗎？這提出了一個令人驚奇的困難問題。Kleene星號和聯集明顯是需要的，但是我們或許可以限制它們的使用。由於正規表示式如此簡單，沒有辦法在語法上把它重寫成某種規範形式。過去公理化的缺乏導致了星號高度問題（英語：Star height problem）。最近Dexter Kozen用克萊尼代數公理化了正規表示式。[來源請求]

很多現實世界的「正規表示式」引擎實現了不能用正規表示式代數表達的特徵。[來源請求]

一個正規表示式通常被稱為一個模式（pattern），為用來描述或者符合一系列符合某個句法規則的字串。例如：Handel、Händel和Haendel這三個字串，都可以由H(a|ä|ae)ndel這個模式來描述。大部分正規表示式的形式都有如下的結構：

某個字元後的數量限定符用來限定前面這個字元允許出現的個數。最常見的數量限定符包括+、?和*（不加數量限定則代表出現一次且僅出現一次）：

上述這些構造子都可以自由組合，因此H(ae?|ä)ndel和H(a|ae|ä)ndel是相同的，表示{"Handel", "Haendel", "Händel"}。

精確的語法可能因不同的工具或程式而異。

正規表示式有多種不同的風格。下表是在PCRE（英語：Perl_Compatible_Regular_Expressions）中元字元及其在正規表示式上下文中的行為的一個完整列表，適用於Perl或者Python程式語言（grep或者egrep的正規表示式文法是PCRE的子集）：

在.NET、Java、JavaScript、Python的正規表示式中，可以用\uXXXX表示一個Unicode字元，其中XXXX為四位16進位數字。

Unicode字元的三種性質：[2]

這三種Unicode性質對應的字元組補集是將開頭的\p改為\P，其它不變。

